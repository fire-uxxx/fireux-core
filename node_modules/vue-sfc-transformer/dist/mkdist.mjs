import process from 'node:process';
import { transform } from 'esbuild';
import { p as preTranspileScriptSetup, t as transpileVueTemplate } from './shared/vue-sfc-transformer.me7vTzGN.mjs';
import '@babel/parser';
import '@vue/compiler-core';

function defineVueLoader(options) {
  const blockLoaders = options?.blockLoaders || {};
  return async (input, context) => {
    if (input.extension !== ".vue") {
      return;
    }
    const { parse } = await import('vue/compiler-sfc');
    let modified = false;
    const raw = await input.getContents();
    const sfc = parse(raw, {
      filename: input.srcPath,
      ignoreEmpty: true
    });
    if (sfc.errors.length > 0) {
      for (const error of sfc.errors) {
        console.error(error);
      }
      throw new Error(`[vue-sfc-transformer] ${input.srcPath} has errors`);
    }
    const isTs = [sfc.descriptor.script, sfc.descriptor.scriptSetup].some(
      (block) => block?.lang === "ts"
    );
    const output = [];
    const addOutput = (...files2) => output.push(...files2);
    const blocks = [
      ...sfc.descriptor.styles,
      ...sfc.descriptor.customBlocks
    ].filter((item) => !!item);
    if (sfc.descriptor.template) {
      blocks.unshift(sfc.descriptor.template);
    }
    if (sfc.descriptor.script) {
      blocks.unshift(sfc.descriptor.script);
    }
    if (sfc.descriptor.scriptSetup && input.srcPath) {
      blocks.unshift(
        isTs ? await preTranspileScriptSetup(sfc.descriptor, input.srcPath) : sfc.descriptor.scriptSetup
      );
    }
    const files = await context.loadFile({
      path: `${input.path}.js`,
      srcPath: `${input.srcPath}.js`,
      extension: ".js",
      getContents: () => "export default {}"
    });
    addOutput(...files?.filter((f) => f.declaration) || []);
    const results = await Promise.all(
      blocks.map(async (data) => {
        const blockLoader = blockLoaders[data.type];
        const result = await blockLoader?.(data, {
          ...context,
          rawInput: input,
          addOutput,
          requireTranspileTemplate: isTs
        }).catch((cause) => {
          throw new Error(`[vue-sfc-transformer] Failed to load the ${data.type} block in ${input.srcPath}`, { cause });
        });
        if (result) {
          modified = true;
        }
        return { block: result || data, offset: data.loc.start.offset };
      })
    );
    if (!modified) {
      addOutput({
        path: input.path,
        srcPath: input.srcPath,
        extension: ".vue",
        contents: raw,
        declaration: false
      });
      return output;
    }
    const contents = results.sort((a, b) => a.offset - b.offset).map(({ block }) => {
      const attrs = Object.entries(block.attrs).map(([key, value]) => {
        if (!value) {
          return void 0;
        }
        return value === true ? key : `${key}="${value}"`;
      }).filter((item) => !!item).join(" ");
      const header = `<${`${block.type} ${attrs}`.trim()}>`;
      const footer = `</${block.type}>`;
      return `${header}
${cleanupBreakLine(block.content)}
${footer}
`;
    }).filter((item) => !!item).join("\n");
    if (context.options._verify || process.env.VERIFY_VUE_FILES) {
      const { parse: parse2 } = await import('vue/compiler-sfc');
      const { errors } = parse2(contents, {
        filename: input.srcPath,
        ignoreEmpty: true
      });
      if (errors.length > 0) {
        for (const error of errors) {
          console.error(error);
        }
        throw new Error(`[vue-sfc-transformer] ${input.srcPath} has errors`);
      }
    }
    addOutput({
      path: input.path,
      srcPath: input.srcPath,
      extension: ".vue",
      contents,
      declaration: false
    });
    return output;
  };
}
function defineDefaultBlockLoader(options) {
  return async (block, { loadFile, rawInput, addOutput }) => {
    if (options.type !== block.type) {
      return;
    }
    const lang = typeof block.attrs.lang === "string" ? block.attrs.lang : options.defaultLang;
    const extension = `.${lang}`;
    const files = await loadFile({
      getContents: () => block.content,
      path: `${rawInput.path}${extension}`,
      srcPath: `${rawInput.srcPath}${extension}`,
      extension
    }) || [];
    const blockOutputFile = files.find(
      (f) => f.extension === `.${options.defaultLang}` || options.validExtensions?.includes(f.extension)
    );
    if (!blockOutputFile) {
      return;
    }
    addOutput(...files.filter((f) => f !== blockOutputFile));
    return {
      type: block.type,
      attrs: toOmit(block.attrs, ["lang", "generic"]),
      content: blockOutputFile.contents
    };
  };
}
const templateLoader = async (rawBlock, { requireTranspileTemplate, loadFile, rawInput }) => {
  if (rawBlock.type !== "template") {
    return;
  }
  if (!requireTranspileTemplate) {
    return;
  }
  const block = rawBlock;
  const transformed = await transpileVueTemplate(
    // for lower version of @vue/compiler-sfc, `ast.source` is the whole .vue file
    block.content,
    block.ast,
    block.loc.start.offset,
    async (code) => {
      const res = await loadFile({
        getContents: () => code,
        path: `${rawInput.path}.ts`,
        srcPath: `${rawInput.srcPath}.ts`,
        extension: ".ts"
      });
      return res?.find((f) => [".js", ".mjs", ".cjs"].includes(f.extension))?.contents || code;
    }
  );
  return {
    type: "template",
    content: transformed,
    attrs: block.attrs
  };
};
const styleLoader = defineDefaultBlockLoader({
  defaultLang: "css",
  type: "style"
});
const scriptLoader = async (block, { options }) => {
  if (block.type !== "script") {
    return;
  }
  const { code: result } = await transform(block.content, {
    ...options.esbuild,
    loader: "ts",
    tsconfigRaw: { compilerOptions: { target: "ESNext", verbatimModuleSyntax: true } }
  });
  return {
    type: block.type,
    attrs: toOmit(block.attrs, ["lang", "generic"]),
    content: result
  };
};
const vueLoader = defineVueLoader({
  blockLoaders: {
    script: scriptLoader,
    template: templateLoader,
    style: styleLoader
  }
});
function cleanupBreakLine(str) {
  return str.replaceAll(/(\n\n)\n+/g, "\n\n").replace(/^\s*\n|\n\s*$/g, "");
}
function toOmit(record, toRemove) {
  return Object.fromEntries(Object.entries(record).filter(([key]) => !toRemove.includes(key)));
}

export { vueLoader };
