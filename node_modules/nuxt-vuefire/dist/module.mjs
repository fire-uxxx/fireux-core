import { readFileSync } from 'node:fs';
import { template } from 'lodash-es';
import { fileURLToPath } from 'node:url';
import { normalize } from 'node:path';
import { defineNuxtModule, createResolver, addPlugin, addPluginTemplate, addServerHandler, addImports } from '@nuxt/kit';
import { markRaw } from 'vue';
import { consola } from 'consola';

async function autodetectEmulators({ emulators: options, auth }, logger) {
  const defaultHost = options.host || "127.0.0.1";
  const isEmulatorEnabled = (
    // emulators is always defined
    options.enabled && // Disable emulators on production unless the user explicitly enables them
    (process.env.NODE_ENV !== "production" || process.env.VUEFIRE_EMULATORS && process.env.VUEFIRE_EMULATORS !== "false")
  );
  if (!isEmulatorEnabled) {
    return null;
  }
  const emulatorsResponse = await fetch(
    `http://${defaultHost}:4400/emulators`
  ).then((res) => {
    return res.status === 200 ? res.json() : null;
  }).catch((err) => {
    if (err instanceof Error && typeof err.cause === "object" && // @ts-expect-error: not in the types
    err.cause?.code !== "ECONNREFUSED") {
      logger.error("Error fetching emulators", err);
    }
    return null;
  });
  if (!emulatorsResponse) {
    return null;
  }
  const emulatorsToEnable = services.reduce((acc, service) => {
    if (emulatorsResponse[service]) {
      let { host, port } = emulatorsResponse[service];
      const envKey = service === "firestore" ? "FIRESTORE_EMULATOR_HOST" : `FIREBASE_${service.toUpperCase()}_EMULATOR_HOST`;
      if (process.env[envKey]) {
        logger.debug(
          `Using the "${envKey}" env variable to enable the "${service}" emulator.`
        );
        try {
          const url = new URL(`http://${process.env[envKey]}`);
          host = url.hostname;
          port = Number(url.port);
        } catch (err) {
          logger.error(
            `The "${envKey}" env variable is set but it is not a valid URL. It should be something like "127.0.0.1:8080". It will be ignored in favor of the "firebase.json" values.`
          );
        }
      }
      acc[service] = { host, port };
    }
    return acc;
  }, {});
  if (!auth) {
    delete emulatorsToEnable.auth;
    if (process.env.FIREBASE_AUTH_EMULATOR_HOST) {
      logger.warn(
        `The "FIREBASE_AUTH_EMULATOR_HOST" env variable is set but the "vuefire.auth" option is not enabled. The env variable will be ignored and the auth emulator won't be enabled.`
      );
      delete process.env.FIREBASE_AUTH_EMULATOR_HOST;
    }
  }
  return emulatorsToEnable;
}
const services = [
  "auth",
  "database",
  "firestore",
  "functions",
  "storage"
];

const logger = consola.withTag("nuxt-vuefire module");
const module = defineNuxtModule({
  meta: {
    name: "vuefire",
    configKey: "vuefire",
    compatibility: {
      nuxt: ">=3.1.0"
    }
  },
  defaults: {
    optionsApiPlugin: false,
    emulators: { enabled: true }
  },
  async setup(_options, nuxt) {
    if (!_options.config) {
      throw new Error(
        '[nuxt-vuefire]: Missing firebase config. Provide a "config" option to the VueFire module options.'
      );
    }
    const isAuthEnabled = typeof _options.auth === "object" ? _options.auth.enabled ?? true : !!_options.auth;
    const options = {
      ..._options,
      // NOTE: TS complains otherwise
      config: _options.config,
      // ensure the resolved version easier to consume
      emulators: {
        enabled: typeof _options.emulators === "object" ? _options.emulators.enabled ?? true : !!_options.emulators,
        ...typeof _options.emulators === "object" ? _options.emulators : {}
      },
      auth: {
        enabled: isAuthEnabled,
        errorMap: process.env.NODE_ENV !== "production" ? "debug" : "prod",
        persistence: ["indexedDBLocal", "browserLocal"],
        popupRedirectResolver: "browser",
        ...typeof _options.auth === "object" ? _options.auth : {}
      }
    };
    nuxt.options.runtimeConfig.public.vuefire ??= {};
    markRaw(nuxt.options.runtimeConfig.public.vuefire);
    nuxt.options.runtimeConfig.public.vuefire.config = _options.config;
    nuxt.options.runtimeConfig.public.vuefire.appCheck = options.appCheck;
    nuxt.options.runtimeConfig.vuefire ??= {};
    markRaw(nuxt.options.runtimeConfig.vuefire);
    nuxt.options.runtimeConfig.vuefire.admin ??= options.admin;
    nuxt.options.runtimeConfig.vuefire.auth ??= options.auth;
    const { resolve } = createResolver(import.meta.url);
    const runtimeDir = fileURLToPath(new URL("./runtime", import.meta.url));
    const templatesDir = fileURLToPath(new URL("../templates", import.meta.url));
    const emulatorsConfig = await autodetectEmulators(options, logger);
    addPlugin(resolve(runtimeDir, "payload-plugin"));
    nuxt.options.build.transpile.push(runtimeDir);
    nuxt.options.build.transpile.push(templatesDir);
    const hasServiceAccount = typeof process.env.GOOGLE_APPLICATION_CREDENTIALS === "string" && process.env.GOOGLE_APPLICATION_CREDENTIALS.length > 0;
    if (typeof process.env.GOOGLE_APPLICATION_CREDENTIALS === "string" && process.env.GOOGLE_APPLICATION_CREDENTIALS?.[0] !== "{") {
      const resolvedCredentials = resolve(
        nuxt.options.rootDir,
        process.env.GOOGLE_APPLICATION_CREDENTIALS
      );
      process.env.GOOGLE_APPLICATION_CREDENTIALS = resolvedCredentials;
    }
    if (options.appCheck) {
      if (!process.env.GOOGLE_APPLICATION_CREDENTIALS && emulatorsConfig) {
        logger.info(
          'Disabling App Check in the context of emulators as no "GOOGLE_APPLICATION_CREDENTIALS" env variable was defined.'
        );
      } else {
        if (process.env.FIREBASE_APPCHECK_DEBUG_TOKEN && // only use the debug token if the user explicitly set debug to true or if nothing was provided and we are not in production
        (options.appCheck.debug === true || // allow a manual override from the console before bundling
        process.env.VUEFIRE_APPCHECK_DEBUG || options.appCheck.debug == null && process.env.NODE_ENV !== "production")) {
          logger.debug(
            `Using app check debug token from env variable "${process.env.FIREBASE_APPCHECK_DEBUG_TOKEN}"`
          );
          if (process.env.NODE_ENV === "production" && options.appCheck.debug) {
            logger.warn(
              "You are using a debug token in production, DO NOT DEPLOY THIS BUILD. If you do, you will leak your debug app check token."
            );
          }
          options.appCheck.debug = process.env.FIREBASE_APPCHECK_DEBUG_TOKEN;
        } else if (emulatorsConfig) {
          logger.debug("Detected Emulators environment, using debug App Check");
          options.appCheck.debug ??= true;
        }
        addPlugin(resolve(runtimeDir, "app-check/plugin.client"));
        if (hasServiceAccount || emulatorsConfig) {
          addPlugin(resolve(runtimeDir, "app-check/plugin.server"));
        } else if (nuxt.options.ssr && !emulatorsConfig) {
          logger.warn(
            "You activated both SSR and app-check but you are not providing a service account for the admin SDK. See https://vuefire.vuejs.org/nuxt/getting-started.html#configuring-the-admin-sdk."
          );
        }
      }
    }
    addPluginTemplate({
      getContents({ options: options2 }) {
        const contents = readFileSync(
          normalize(resolve(templatesDir, "plugin.ejs")),
          "utf-8"
        );
        return template(contents)({ options: options2 });
      },
      filename: "vuefire-plugin.mjs",
      options: {
        ssr: nuxt.options.ssr
      }
    });
    if (options.auth.enabled) {
      if (nuxt.options.ssr && !hasServiceAccount && !emulatorsConfig) {
        logger.warn(
          "You activated both SSR and auth but you are not providing a service account for the admin SDK. See https://vuefire.vuejs.org/nuxt/getting-started.html#configuring-the-admin-sdk."
        );
      }
      if (nuxt.options.ssr && (hasServiceAccount || emulatorsConfig) && options.auth.sessionCookie) {
        logger.debug("Enabling session cookie verification endpoint");
        addServerHandler({
          route: "/api/__session",
          handler: resolve(runtimeDir, "./auth/api.session-verification")
        });
        addPlugin(resolve(runtimeDir, "auth/plugin-mint-cookie.client"));
      }
      addPlugin(resolve(runtimeDir, "auth/plugin-authenticate-user.server"));
    }
    if (emulatorsConfig) {
      const emulators = emulatorsConfig;
      if (emulators?.auth) {
        emulators.auth.options = options.emulators.auth?.options;
      }
      nuxt.options.runtimeConfig.public.vuefire.emulators = emulators;
      for (const serviceName in emulators) {
        const { host, port } = emulators[serviceName];
        process.env[serviceName === "firestore" ? "FIRESTORE_EMULATOR_HOST" : `FIREBASE_${serviceName.toUpperCase()}_EMULATOR_HOST`] = `${host}:${port}`;
        logger.info(`Enabling ${serviceName} emulator at ${host}:${port}`);
        addPlugin(resolve(runtimeDir, `emulators/${serviceName}.plugin`));
      }
    }
    if (options.auth.enabled) {
      addPluginTemplate({
        getContents({ options: options2 }) {
          const contents = readFileSync(
            normalize(resolve(runtimeDir, "auth/plugin.client.ejs")),
            "utf-8"
          );
          return template(contents)({ options: options2 });
        },
        filename: "vuefire-auth-plugin.client.mjs",
        options: {
          ...options.auth
        }
      });
      addPlugin(resolve(runtimeDir, "auth/plugin.server"));
      addVueFireImports([
        // auth
        { from: "vuefire", name: "useFirebaseAuth" },
        { from: "vuefire", name: "useCurrentUser" }
      ]);
      addImports([
        {
          from: resolve(runtimeDir, "auth/composables"),
          name: "getCurrentUser"
        }
      ]);
    }
    addPlugin(resolve(runtimeDir, "app/plugin.client"));
    addPlugin(resolve(runtimeDir, "app/plugin.server"));
    if (options.admin || nuxt.options.ssr) {
      if (!nuxt.options.ssr) {
        logger.warn(
          'The "admin" option is only used during SSR. You should reenable SSR to use it or remove it if you are not doing SSR or SSG.'
        );
      }
      if (hasServiceAccount || emulatorsConfig) {
        if (options.auth.enabled && options.auth.sessionCookie) {
          addPlugin(resolve(runtimeDir, "auth/plugin-user-token.server"));
        }
        addPlugin(resolve(runtimeDir, "admin/plugin.server"));
        if (emulatorsConfig) {
          options.admin ??= {};
          options.admin.options ??= {};
          options.admin.options.projectId ??= options.config.projectId;
        }
      }
    }
    addImports([
      // app
      {
        from: resolve(runtimeDir, "app/composables"),
        name: "useFirebaseApp"
      }
    ]);
    addVueFireImports([
      // firestore
      { from: "vuefire", name: "useFirestore" },
      { from: "vuefire", name: "useDocument" },
      { from: "vuefire", name: "useCollection" },
      // database
      { from: "vuefire", name: "useDatabase" },
      { from: "vuefire", name: "useDatabaseList" },
      { from: "vuefire", name: "useDatabaseObject" },
      // storage
      { from: "vuefire", name: "useFirebaseStorage" },
      { from: "vuefire", name: "useStorageFile" },
      { from: "vuefire", name: "useStorageFileUrl" },
      { from: "vuefire", name: "useStorageFileMetadata" }
    ]);
  },
  // workaround for vite
  hooks: {
    "vite:extendConfig": (viteInlineConfig, env) => {
      viteInlineConfig.resolve ??= {};
      viteInlineConfig.resolve.dedupe ??= [];
      const deps = [
        // 'vuefire',
        // 'nuxt-vuefire',
        "firebase",
        "firebase/app",
        "@firebase/app",
        // NOTE: some of these do not seem to change anything
        "firebase/app-check",
        "@firebase/app-check",
        "firebase/firestore",
        "@firebase/firestore",
        "firebase/auth",
        "@firebase/auth",
        "@firebase/component",
        "firebase-admin/auth",
        "firebase-admin/app",
        "firebase-admin/app-check"
      ];
      viteInlineConfig.resolve.dedupe.push(...deps);
      viteInlineConfig.optimizeDeps ??= {};
      viteInlineConfig.optimizeDeps.exclude ??= [];
      viteInlineConfig.optimizeDeps.exclude.push(...deps);
    }
  }
});
function addVueFireImports(imports) {
  return addImports(imports);
}

export { module as default };
